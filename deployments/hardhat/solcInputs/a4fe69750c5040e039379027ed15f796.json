{
  "language": "Solidity",
  "sources": {
    "contracts/WineryProgression.sol": {
      "content": "// Winery\r\n//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ninterface IGrape {\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function burn(address owner, uint256 index) external returns (uint256);\r\n}\r\n\r\ninterface IWinery {\r\n    function skillPoints(address owner) external view returns (uint256);\r\n    function skillsLearned(address owner, uint256 index) external view returns (uint256);\r\n    function grapeDeposited(address owner) external view returns (uint256);\r\n}\r\n\r\ncontract WineryProgression is Ownable {\r\n\r\n    // Constants\r\n    uint256 public constant BURN_ID = 0;\r\n    uint256 public constant FATIGUE_ID = 1;\r\n    uint256 public constant CELLAR_ID = 2;\r\n    uint256 public constant MASTERVINTNER_ID = 3;\r\n    uint256 public constant UPGRADES_ID = 4;\r\n    uint256 public constant VINTNERS_ID = 5;\r\n    uint256 public constant STORAGE_ID = 6;\r\n    // uint256 public constant MAFIA_ID = 7;\r\n\r\n    uint256[30] public grapeLevels = [0, 20 * 1e18, 48 * 1e18, 83 * 1e18, 125 * 1e18, 175 * 1e18, 235 * 1e18, 310 * 1e18, 400 * 1e18, \r\n        510 * 1e18, 641 * 1e18, 805 * 1e18, 1001 * 1e18, 1213 * 1e18, 1497 * 1e18, 1851 * 1e18, 2276 * 1e18, 2772 * 1e18, 3322 * 1e18, 3932 * 1e18,\r\n        4694 * 1e18, 5608 * 1e18, 6658 * 1e18, 7877 * 1e18, 9401 * 1e18, 11229 * 1e18, 13363 * 1e18, 15801 * 1e18, 18545 * 1e18, 21593 * 1e18];\r\n\r\n    uint256 public maxGrapeAmount = grapeLevels[grapeLevels.length - 1];\r\n    uint256 public baseCostRespect = 25 * 1e18;\r\n\r\n    uint256[4] public burnSkillValue = [0,3,6,8];\r\n    uint256[6] public fatigueSkillValue = [100,92,85,80,70,50];\r\n    uint256[3] public cellarSkillValue = [0,4,9];\r\n    uint256[3] public masterVintnerSkillValue = [100,103,110];\r\n    uint256[6] public upgradesSkillValue = [1,4,6,8,11,100];\r\n    uint256[6] public vintnersSkillValue = [10,15,20,30,50,20000];\r\n    uint256[6] public vintageWineStorageSkillValue = [6000 * 1e18, 15000 * 1e18, 50000 * 1e18, 100000 * 1e18, 300000 * 1e18, 500000 * 1e18];\r\n    // uint256[4] public mafiaModSkillValue = [0,3,6,10];\r\n\r\n    uint256[8] public MAX_SKILL_LEVEL = [\r\n        burnSkillValue.length - 1,\r\n        fatigueSkillValue.length - 1,\r\n        cellarSkillValue.length - 1,\r\n        masterVintnerSkillValue.length - 1,\r\n        upgradesSkillValue.length - 1,\r\n        vintnersSkillValue.length - 1,\r\n        vintageWineStorageSkillValue.length - 1\r\n        // mafiaModSkillValue.length - 1\r\n    ];\r\n\r\n    IGrape public grape;\r\n\r\n    uint256 public levelTime;\r\n\r\n    mapping(address => uint256) public grapeDeposited; // address => total amount of grape deposited\r\n    mapping(address => uint256) public skillPoints; // address => skill points available\r\n    mapping(address => uint256[8]) public skillsLearned; // address => skill learned.\r\n\r\n    constructor(address _grape) {\r\n        grape = IGrape(_grape);\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    event receivedSkillPoints(address owner, uint256 skillPoints);\r\n    event skillLearned(address owner, uint256 skillGroup, uint256 skillLevel);\r\n    event respec(address owner, uint256 level);\r\n\r\n    // Setters\r\n    function setburnSkillValue(uint256 _index, uint256 _value) external onlyOwner {\r\n        burnSkillValue[_index] = _value;\r\n    }\r\n    function setfatigueSkillValue(uint256 _index, uint256 _value) external onlyOwner {\r\n        fatigueSkillValue[_index] = _value;\r\n    }\r\n    function setcellarSkillValue(uint256 _index, uint256 _value) external onlyOwner {\r\n        cellarSkillValue[_index] = _value;\r\n    }\r\n    function setmasterVintnerSkillValue(uint256 _index, uint256 _value) external onlyOwner {\r\n        masterVintnerSkillValue[_index] = _value;\r\n    }\r\n    function setupgradesSkillValue(uint256 _index, uint256 _value) external onlyOwner {\r\n        upgradesSkillValue[_index] = _value;\r\n    }\r\n    function setvintnersSkillValue(uint256 _index, uint256 _value) external onlyOwner {\r\n        vintnersSkillValue[_index] = _value;\r\n    }\r\n    function setvintageWineStorageSkillValue(uint256 _index, uint256 _value) external onlyOwner {\r\n        vintageWineStorageSkillValue[_index] = _value;\r\n    }\r\n    // function setmafiaModSkillValue(uint256 _index, uint256 _value) external onlyOwner {\r\n    //     mafiaModSkillValue[_index] = _value;\r\n    // }\r\n    \r\n    function setGrape(address _grape) external onlyOwner {\r\n        grape = IGrape(_grape);\r\n    }\r\n\r\n    function setBaseCostRespect(uint256 _baseCostRespect) external onlyOwner {\r\n        baseCostRespect = _baseCostRespect;\r\n    }\r\n\r\n    function setGrapeLevels(uint256 _index, uint256 _newValue) external onlyOwner {\r\n        require (_index < grapeLevels.length, \"invalid index\");\r\n        grapeLevels[_index] = _newValue;\r\n\r\n        if(_index == (grapeLevels.length - 1)){\r\n            maxGrapeAmount = grapeLevels[grapeLevels.length - 1];\r\n        }\r\n    }\r\n\r\n    // Views\r\n\r\n    /**\r\n    * Returns the level based on the total grape deposited\r\n    */\r\n    function _getLevel(address _owner) internal view returns (uint256) {\r\n        uint256 totalGrape = grapeDeposited[_owner];\r\n        uint256 maxId = grapeLevels.length - 1;\r\n\r\n        for (uint256 i = 0; i < maxId; i++) {\r\n            if (totalGrape < grapeLevels[i+1]) {\r\n                    return i+1;\r\n            }\r\n        }\r\n        return grapeLevels.length;\r\n    }\r\n\r\n    /**\r\n    * Returns a value representing the % of fatigue after reducing\r\n    */\r\n    function getFatigueSkillModifier(address _owner) public view returns (uint256) {\r\n        uint256 fatigueSkill = skillsLearned[_owner][FATIGUE_ID];\r\n        return fatigueSkillValue[fatigueSkill];\r\n    }\r\n\r\n    /**\r\n    * Returns a value representing the % that will be reduced from the claim burn\r\n    */\r\n    function getBurnSkillModifier(address _owner) public view returns (uint256) {\r\n        uint256 burnSkill = skillsLearned[_owner][BURN_ID];\r\n        return burnSkillValue[burnSkill];\r\n    }\r\n\r\n    /**\r\n    * Returns a value representing the % that will be reduced from the cellar share of the claim\r\n    */\r\n    function getCellarSkillModifier(address _owner) public view returns (uint256) {\r\n        uint256 cellarSkill = skillsLearned[_owner][CELLAR_ID];\r\n        return cellarSkillValue[cellarSkill];\r\n    }\r\n\r\n    /**\r\n    * Returns the multiplier for $VINTAGEWINE production based on the number of mastervintners and the skill points spent\r\n    */\r\n    function getMasterVintnerSkillModifier(address _owner, uint256 _masterVintnerNumber) public view returns (uint256) {\r\n        uint256 masterVintnerSkill = skillsLearned[_owner][MASTERVINTNER_ID];\r\n\r\n        if(masterVintnerSkill == 2 && _masterVintnerNumber >= 5){\r\n            return masterVintnerSkillValue[2];\r\n        } else if (masterVintnerSkill >= 1 && _masterVintnerNumber >= 2){\r\n            return masterVintnerSkillValue[1];\r\n        } else {\r\n            return masterVintnerSkillValue[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Returns the max level upgrade that can be staked based on the skill points spent\r\n    */\r\n    function getMaxLevelUpgrade(address _owner) public view returns (uint256) {\r\n        uint256 upgradesSkill = skillsLearned[_owner][UPGRADES_ID];\r\n        return upgradesSkillValue[upgradesSkill];\r\n    }\r\n\r\n    /**\r\n    * Returns the max number of vintners that can be staked based on the skill points spent\r\n    */\r\n    function getMaxNumberVintners(address _owner) public view returns (uint256) {\r\n        uint256 vintnersSkill = skillsLearned[_owner][VINTNERS_ID];\r\n        return vintnersSkillValue[vintnersSkill];\r\n    }\r\n\r\n    /**\r\n    * Returns the modifier for mafia mechanic\r\n    */\r\n    // function getMafiaModifier(address _owner) public view returns (uint256) {\r\n    //     uint256 mafiaModSkill = skillsLearned[_owner][MAFIA_ID];\r\n    //     return mafiaModSkillValue[mafiaModSkill];\r\n    // }\r\n\r\n    /**\r\n    * Returns the max storage for vintageWine in the winery\r\n    */\r\n    function getVintageWineStorage(address _owner) public view returns (uint256) {\r\n        uint256 vintageWineStorageSkill = skillsLearned[_owner][STORAGE_ID];\r\n        return vintageWineStorageSkillValue[vintageWineStorageSkill];\r\n    }\r\n\r\n    // Public views\r\n\r\n    /**\r\n    * Returns the Winery level\r\n    */\r\n    function getLevel(address _owner) public view returns (uint256) {\r\n        return _getLevel(_owner);\r\n    }\r\n\r\n    /**\r\n    * Returns the $GRAPE deposited in the current level\r\n    */\r\n    function getGrapeDeposited(address _owner) public view returns (uint256) {\r\n        uint256 level = _getLevel(_owner);\r\n        uint256 totalGrape = grapeDeposited[_owner];\r\n        if(level == grapeLevels.length){\r\n            return 0;\r\n        }\r\n\r\n        return totalGrape - grapeLevels[level-1];\r\n    }\r\n\r\n    /**\r\n    * Returns the amount of grape required to level up\r\n    */\r\n    function getGrapeToNextLevel(address _owner) public view returns (uint256) {\r\n        uint256 level = _getLevel(_owner);\r\n        if(level == grapeLevels.length){\r\n            return 0;\r\n        }\r\n        return grapeLevels[level] - grapeLevels[level-1];\r\n    }\r\n\r\n    /**\r\n    * Returns the amount of skills points available to be spent\r\n    */\r\n    function getSkillPoints(address _owner) public view returns (uint256) {\r\n        return skillPoints[_owner];\r\n    }\r\n\r\n    /**\r\n    * Returns the current skills levels for each skill group\r\n    */\r\n    function getSkillsLearned(address _owner) public view returns (\r\n        uint256 burn,\r\n        uint256 fatigue,\r\n        uint256 cellar,\r\n        uint256 mastervintner,\r\n        uint256 upgrades,\r\n        uint256 vintners,     \r\n        uint256 vintageWineStorage\r\n        // uint256 mafiaMod     \r\n    ) {\r\n        uint256[8] memory skills = skillsLearned[_owner];\r\n\r\n        burn = skills[BURN_ID];\r\n        fatigue = skills[FATIGUE_ID]; \r\n        cellar = skills[CELLAR_ID]; \r\n        mastervintner = skills[MASTERVINTNER_ID]; \r\n        upgrades = skills[UPGRADES_ID];\r\n        vintners = skills[VINTNERS_ID]; \r\n        vintageWineStorage = skills[STORAGE_ID]; \r\n        // mafiaMod = skills[MAFIA_ID]; \r\n    }\r\n\r\n    // External\r\n\r\n    /**\r\n    * Burns deposited $GRAPE and add skill point if level up.\r\n    */\r\n    function depositGrape(uint256 _amount) external {\r\n        address sender = msg.sender;\r\n        require(levelStarted(), \"You can't level yet\");\r\n        require (_getLevel(sender) < grapeLevels.length, \"already at max level\");\r\n        require (grape.balanceOf(sender) >= _amount, \"not enough GRAPE\");\r\n\r\n        if(_amount + grapeDeposited[sender] > maxGrapeAmount){\r\n            _amount = maxGrapeAmount - grapeDeposited[sender];\r\n        }\r\n\r\n        grape.burn(sender, _amount);\r\n\r\n        uint256 levelBefore = _getLevel(sender);\r\n        grapeDeposited[sender] += _amount;\r\n        uint256 levelAfter = _getLevel(sender);\r\n        skillPoints[sender] += levelAfter - levelBefore;\r\n\r\n        if(levelAfter == grapeLevels.length){\r\n            skillPoints[sender] += 1;\r\n        }\r\n\r\n        emit receivedSkillPoints(sender, levelAfter - levelBefore);\r\n    }\r\n\r\n    /**\r\n    *  Spend skill point based on the skill group and skill level. Can only spend 1 point at a time.\r\n    */\r\n    function spendSkillPoints(uint256 _skillGroup, uint256 _skillLevel) external {\r\n        address sender = msg.sender;\r\n\r\n        require(skillPoints[sender] > 0, \"Not enough skill points\");\r\n        require (_skillGroup <= MAX_SKILL_LEVEL.length - 1, \"Invalid Skill Group\");\r\n        require(_skillLevel >= 1 && _skillLevel <= MAX_SKILL_LEVEL[_skillGroup], \"Invalid Skill Level\");\r\n        \r\n        uint256 currentSkillLevel = skillsLearned[sender][_skillGroup];\r\n        require(_skillLevel == currentSkillLevel + 1, \"Invalid Skill Level jump\"); //can only level up 1 point at a time\r\n\r\n        skillsLearned[sender][_skillGroup] = _skillLevel;\r\n        skillPoints[sender]--;\r\n\r\n        emit skillLearned(sender, _skillGroup, _skillLevel);\r\n    }\r\n\r\n    /**\r\n    *  Resets skills learned for a fee\r\n    */\r\n    function resetSkills() external {\r\n        address sender = msg.sender;\r\n        uint256 level = _getLevel(sender);\r\n        uint256 costToRespec = level * baseCostRespect;\r\n        require (level > 1, \"you are still at level 1\");\r\n        require (grape.balanceOf(sender) >= costToRespec, \"not enough GRAPE\");\r\n\r\n        grape.burn(sender, costToRespec);\r\n\r\n        skillsLearned[sender][BURN_ID] = 0;\r\n        skillsLearned[sender][FATIGUE_ID] = 0;\r\n        skillsLearned[sender][CELLAR_ID] = 0;\r\n        skillsLearned[sender][MASTERVINTNER_ID] = 0;\r\n        skillsLearned[sender][UPGRADES_ID] = 0;\r\n        skillsLearned[sender][VINTNERS_ID] = 0;\r\n        skillsLearned[sender][STORAGE_ID] = 0;\r\n        // skillsLearned[sender][MAFIA_ID] = 0;\r\n\r\n        skillPoints[sender] = level - 1;\r\n\r\n        if(level == grapeLevels.length){\r\n            skillPoints[sender] += 1;\r\n        }\r\n\r\n        emit respec(sender, level);\r\n\r\n    }\r\n\r\n    // Admin\r\n\r\n    function levelStarted() public view returns (bool) {\r\n        return levelTime != 0 && block.timestamp >= levelTime;\r\n    }\r\n\r\n    function setLevelStartTime(uint256 _startTime) external onlyOwner {\r\n        require (_startTime >= block.timestamp, \"startTime cannot be in the past\");\r\n        require(!levelStarted(), \"leveling already started\");\r\n        levelTime = _startTime;\r\n    }\r\n\r\n\r\n    // In case we rebalance the leveling costs this fixes the skill points to correct players\r\n    function fixSkillPoints(address _player) public {\r\n        uint256 level = _getLevel(_player);\r\n        uint256 currentSkillPoints = skillPoints[_player];\r\n        // uint256 totalSkillsLearned = skillsLearned[_player][BURN_ID] + skillsLearned[_player][FATIGUE_ID] + skillsLearned[_player][CELLAR_ID] + skillsLearned[_player][MASTERVINTNER_ID] + skillsLearned[_player][UPGRADES_ID] + skillsLearned[_player][VINTNERS_ID] + skillsLearned[_player][STORAGE_ID] + skillsLearned[_player][MAFIA_ID];\r\n        uint256 totalSkillsLearned = skillsLearned[_player][BURN_ID] + skillsLearned[_player][FATIGUE_ID] + skillsLearned[_player][CELLAR_ID] + skillsLearned[_player][MASTERVINTNER_ID] + skillsLearned[_player][UPGRADES_ID] + skillsLearned[_player][VINTNERS_ID] + skillsLearned[_player][STORAGE_ID];\r\n\r\n        uint256 correctSkillPoints = level - 1;\r\n        if(level == grapeLevels.length){ // last level has 2 skill points\r\n            correctSkillPoints += 1;\r\n        }\r\n        if(correctSkillPoints > currentSkillPoints + totalSkillsLearned){\r\n            skillPoints[_player] += correctSkillPoints - currentSkillPoints - totalSkillsLearned;\r\n        }\r\n    }\r\n\r\n        // WINERY MIGRATION\r\n    IWinery public oldWinery;\r\n    mapping(address => bool) public updateOnce; // owner => has updated\r\n\r\n    function checkIfNeedUpdate(address _owner) public view returns (bool) {\r\n        if(updateOnce[_owner]){\r\n            return false; // does not need update if already updated\r\n        }\r\n\r\n        uint256 oldGrapeDeposited = oldWinery.grapeDeposited(_owner);\r\n\r\n        if(oldGrapeDeposited > 0){\r\n            return true; // if the player deposited any grape it means he interacted with the Winery improvements\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    function setOldWinery(address _oldWinery) external onlyOwner {\r\n        oldWinery = IWinery(_oldWinery);\r\n    }\r\n\r\n    function updateDataFromOldWinery(address _owner) external {\r\n        require (checkIfNeedUpdate(_owner), \"Owner dont need to update\");\r\n        updateOnce[_owner] = true;\r\n\r\n        grapeDeposited[_owner] = oldWinery.grapeDeposited(_owner);\r\n\r\n        skillPoints[_owner] = oldWinery.skillPoints(_owner);\r\n\r\n        uint256 burnSkillId = oldWinery.skillsLearned(_owner, 0);\r\n        uint256 fatigueSkillId = oldWinery.skillsLearned(_owner, 1);\r\n        uint256 cellarSkillId = oldWinery.skillsLearned(_owner, 2);\r\n        uint256 mastervintnerSkillId = oldWinery.skillsLearned(_owner, 3);\r\n        uint256 upgradeSkillId = oldWinery.skillsLearned(_owner, 4);\r\n        uint256 vintnerSkillId = oldWinery.skillsLearned(_owner, 5);\r\n        \r\n        skillsLearned[_owner] = [burnSkillId, fatigueSkillId, cellarSkillId, mastervintnerSkillId, upgradeSkillId, vintnerSkillId, 0, 0];\r\n\r\n        fixSkillPoints(_owner); // Fix skill points because of rebalance\r\n    }\r\n\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}